<!DOCTYPE html>
<html>
<head>
    <title>DogDrop - P2P File Transfer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .container {
            display: flex;
            gap: 20px;
        }

        .sender, .receiver {
            flex: 1;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
        }

        .drop-zone {
            border: 2px dashed #666;
            padding: 20px;
            text-align: center;
            margin: 10px 0;
            cursor: pointer;
        }

        .drop-zone.dragover {
            background-color: #f0f0f0;
        }

        .file-list {
            margin: 10px 0;
        }

        .file-item {
            margin: 5px 0;
            padding: 5px;
            background-color: #f8f8f8;
            border-radius: 4px;
        }

        textarea {
            width: 100%;
            height: 100px;
            margin: 10px 0;
        }

        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <h1>üêæ DogDrop - P2P File Transfer</h1>
    <div class="container">
        <div class="sender">
            <h2>Sender</h2>
            <div class="drop-zone" id="dropZone">
                Drag & Drop files here or click to select
            </div>
            <input type="file" id="fileInput" hidden>
            <div class="file-list" id="fileList"></div>
            <button onclick="startSharing()">Start Sharing</button>
            <h3>Connection Info:</h3>
            <textarea id="offerArea" placeholder="Offer will appear here..."></textarea>
            <textarea id="answerArea" placeholder="Paste answer here..."></textarea>
            <button onclick="handleAnswer()">Submit Answer</button>
        </div>

        <div class="receiver">
            <h2>Receiver</h2>
            <textarea id="receiverOffer" placeholder="Paste offer here..."></textarea>
            <button onclick="connectToSender()">Connect</button>
            <textarea id="receiverAnswer" placeholder="Answer will appear here..."></textarea>
            <div class="received-files" id="receivedFiles"></div>
        </div>
    </div>

    <script>
        let peerConnection;
        let dataChannel;
        let filesToSend = [];
        let currentFile;
        let chunkSize = 16 * 1024; // 16KB chunks

        // Sender side
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');

        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

        function handleFiles(files) {
            filesToSend = [...files];
            updateFileList();
        }

        function updateFileList() {
            fileList.innerHTML = filesToSend.map(file => `
                <div class="file-item">
                    ${file.name} (${formatSize(file.size)})
                </div>
            `).join('');
        }

        async function startSharing() {
            if (!filesToSend.length) return alert('Please select files first!');
            
            peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            // Setup data channel
            dataChannel = peerConnection.createDataChannel('dogDrop');
            setupDataChannel(dataChannel);

            peerConnection.onicecandidate = e => {
                if (e.candidate) {
                    document.getElementById('offerArea').value = JSON.stringify(peerConnection.localDescription);
                }
            };

            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
            } catch (error) {
                console.error('Error creating offer:', error);
            }
        }

        async function handleAnswer() {
            const answer = document.getElementById('answerArea').value;
            if (!answer) return alert('Please paste answer first!');
            
            try {
                await peerConnection.setRemoteDescription(JSON.parse(answer));
                sendNextFile();
            } catch (error) {
                console.error('Error setting answer:', error);
            }
        }

        function setupDataChannel(channel) {
            channel.onopen = () => {
                console.log('Data channel opened!');
            };
        }

        function sendNextFile() {
            if (!filesToSend.length) return;
            
            currentFile = filesToSend.shift();
            const reader = new FileReader();
            
            reader.onload = async function(e) {
                const buffer = e.target.result;
                const chunks = [];
                
                // Send metadata first
                dataChannel.send(JSON.stringify({
                    type: 'metadata',
                    name: currentFile.name,
                    size: currentFile.size,
                    mimeType: currentFile.type
                }));

                // Send file in chunks
                for (let offset = 0; offset < buffer.byteLength; offset += chunkSize) {
                    const chunk = buffer.slice(offset, offset + chunkSize);
                    dataChannel.send(chunk);
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                
                sendNextFile();
            };
            
            reader.readAsArrayBuffer(currentFile);
        }

        // Receiver side
        async function connectToSender() {
            const offer = document.getElementById('receiverOffer').value;
            if (!offer) return alert('Please paste offer first!');
            
            peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            let receivedFile = {
                name: '',
                size: 0,
                receivedSize: 0,
                chunks: []
            };

            peerConnection.ondatachannel = e => {
                const channel = e.channel;
                channel.onmessage = async event => {
                    if (typeof event.data === 'string') {
                        // Metadata
                        const metadata = JSON.parse(event.data);
                        receivedFile = {
                            name: metadata.name,
                            size: metadata.size,
                            receivedSize: 0,
                            chunks: []
                        };
                        document.getElementById('receivedFiles').innerHTML = `
                            <div class="file-item">
                                Receiving: ${metadata.name} (${formatSize(metadata.size)})
                            </div>
                        `;
                    } else {
                        // File chunk
                        receivedFile.chunks.push(event.data);
                        receivedFile.receivedSize += event.data.byteLength;

                        if (receivedFile.receivedSize === receivedFile.size) {
                            const file = new Blob(receivedFile.chunks, 
                                { type: 'application/octet-stream' });
                            downloadFile(file, receivedFile.name);
                        }
                    }
                };
            };

            peerConnection.onicecandidate = e => {
                if (e.candidate) {
                    document.getElementById('receiverAnswer').value = 
                        JSON.stringify(peerConnection.localDescription);
                }
            };

            try {
                await peerConnection.setRemoteDescription(JSON.parse(offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
            } catch (error) {
                console.error('Error handling offer:', error);
            }
        }

        function downloadFile(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function formatSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
    </script>
</body>
</html>
